<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>–õ–∞–±–∏—Ä–∏–Ω—Ç</title>
  <style>
    :root {
      --w: 350px;
      --h: 550px;
      --bg: #d0f0e2;         /* –§–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü—ã */
      --panel: #255853;      /* –¢–µ–º–Ω—ã–π —Ñ–æ–Ω –ø–∞–Ω–µ–ª–∏ */
      --muted: #64748b;      /* –°–µ—Ä—ã–π –¥–ª—è —Ç–µ–∫—Å—Ç–∞ */
      --text: #e5e7eb;       /* –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç */
      --accent: #22c55e;     /* –ó–µ–ª—ë–Ω—ã–π –∞–∫—Ü–µ–Ω—Ç */
      --accent-2: #ef4444;   /* –ö—Ä–∞—Å–Ω—ã–π */
      --border: #1f2937;     /* –ì—Ä–∞–Ω–∏—Ü—ã */
      --btn: #334155;        /* –ö–Ω–æ–ø–∫–∏ */
      --btn-hover: #475569;
      --game-bg: #94A7A3;    /* –¶–≤–µ—Ç —Ñ–æ–Ω–∞ –∏–≥—Ä—ã */
      --shadow-light: #A6BCB7;
      --shadow-dark: #255853;
      --control-bg: #448778;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: var(--bg);
      font-family: 'Arial', sans-serif;
      user-select: none;
    }

    .container {
      width: 320px;
      height: var(--h);
      background-color: var(--game-bg);
      border: 2px solid #777777;
      border-radius: 50px;
      box-shadow:
        inset 2px 2px 0px 2px var(--shadow-light),
        3px 20px 0px #5B7A78,
        9px 10px 0px #5B7A78,
        0px 40px 0px var(--shadow-dark),
        9px 40px 0px var(--shadow-dark);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      box-sizing: border-box;
      overflow: hidden;
      position: relative;
      color: white;
    }

    .title {
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 10px 0;
      color: #1a3a32;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .timer {
      font-size: 18px;
      margin: 0px 0px 10px 140px;
      color: #1a3a32;
      font-weight: bold;
      background-color: rgba(255,255,255,0.3);
      padding: 5px 15px;
      border-radius: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #container {
      width: 288px;
      height: 288px;
      border: 2px solid #4d4d4d;
      border-radius: 20px;
      background: #000000;
      position: relative;
      overflow: hidden;
      box-shadow: inset 2px 2px 0px 2px #5E7A77;
    }

    canvas {
      display: block;
      border-radius: 20px;
    }

    #win-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
      z-index: 10;
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    }

    .controls {
        display: grid;
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(2, 60px);
        gap: 15px;
        margin-top: 15px;
    }

    .btn {
      width: 60px;
      height: 60px;
      background-color: var(--control-bg);
      color: white;
      font-size: 28px;
      font-weight: bold;
      border: 1px solid #4d4d4d;
      border-radius: 15px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow:
        inset 2px 2px 0px 2px #4E917F,
        0px 7px 0px var(--shadow-dark);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .btn:active {
      transform: translateY(4px);
      box-shadow: 0px 3px 0px var(--shadow-dark);
    }

    .btn-up {
        grid-column: 2; grid-row: 1;
        background-color: #FBD369;
        box-shadow: 0px 4px 0px #D1AE53, 3px 4px 0px #D1AE53;
        border: solid 1px #D1AE53;

    }
    .btn-left {
        grid-column: 1; grid-row: 2;
        background-color: #F16760;
        box-shadow: 0px 4px 0px #BB524A, 3px 4px 0px #BB524A;
        border: solid 1px #BB524A;
    }
    .btn-right {
        grid-column: 3; grid-row: 2;
        background-color: #7DD879;
        box-shadow: 0px 4px 0px #6BBB63, 3px 4px 0px #6BBB63;
        border: solid 1px #6BBB63;
    }
    .btn-down {
        grid-column: 2; grid-row: 2;
        background-color: #578CF8;
        box-shadow: 0px 4px 0px #4369B6, 3px 4px 0px #4369B6;
        border: solid 1px #4369B6;
    }

    .instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 10px;
      color: rgba(255,255,255,0.6);
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div class="container">
<!--    <h1 class="title">–õ–∞–±–∏—Ä–∏–Ω—Ç</h1>-->
    <div class="timer">–í—Ä–µ–º—è: <span id="time">5:00</span></div>

    <div id="container">
      <canvas id="maze" width="300" height="300"></canvas>
      <img id="win-image" src="source_qr.png" alt="–ü–æ–±–µ–¥–∞!" />
    </div>

    <div class="controls">
      <div class="btn btn-up" id="up">‚Üë</div>
      <div class="btn btn-left" id="left">‚Üê</div>
      <div class="btn btn-right" id="right">‚Üí</div>
      <div class="btn btn-down" id="down">‚Üì</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('maze');
    const ctx = canvas.getContext('2d');
    const winImage = document.getElementById('win-image');
    const timeDisplay = document.getElementById('time');

    // –†–∞–∑–º–µ—Ä—ã —è—á–µ–π–∫–∏ –∏ —Å–µ—Ç–∫–∏ –ø–æ–¥ –Ω–æ–≤—ã–π canvas (300x300)
    const CELL_SIZE = 18;
    const COLS = Math.floor(canvas.width / CELL_SIZE); // ~16
    const ROWS = Math.floor(canvas.height / CELL_SIZE); // ~16

    let grid = [];
    let player = { x: 1, y: 1 };
    let exit = { x: COLS - 2, y: ROWS - 2 };
    let gameWon = false;

    class Cell {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.walls = {
          top: true,
          right: true,
          bottom: true,
          left: true
        };
        this.visited = false;
      }

      draw() {
        const x = this.x * CELL_SIZE;
        const y = this.y * CELL_SIZE;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;

        if (this.walls.top) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + CELL_SIZE, y);
          ctx.stroke();
        }
        if (this.walls.right) {
          ctx.beginPath();
          ctx.moveTo(x + CELL_SIZE, y);
          ctx.lineTo(x + CELL_SIZE, y + CELL_SIZE);
          ctx.stroke();
        }
        if (this.walls.bottom) {
          ctx.beginPath();
          ctx.moveTo(x + CELL_SIZE, y + CELL_SIZE);
          ctx.lineTo(x, y + CELL_SIZE);
          ctx.stroke();
        }
        if (this.walls.left) {
          ctx.beginPath();
          ctx.moveTo(x, y + CELL_SIZE);
          ctx.lineTo(x, y);
          ctx.stroke();
        }

        if (this.visited) {
          ctx.fillStyle = 'rgba(31,135,206,0.3)';
          ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
        }
      }

      getNeighbors(grid) {
        const neighbors = [];
        const dirs = [
          { dx: -1, dy: 0, wall: 'left', opp: 'right' },
          { dx: 1, dy: 0, wall: 'right', opp: 'left' },
          { dx: 0, dy: -1, wall: 'top', opp: 'bottom' },
          { dx: 0, dy: 1, wall: 'bottom', opp: 'top' }
        ];

        for (const dir of dirs) {
          const nx = this.x + dir.dx;
          const ny = this.y + dir.dy;
          if (nx >= 0 && ny >= 0 && nx < COLS && ny < ROWS && !grid[ny][nx].visited) {
            neighbors.push({ cell: grid[ny][nx], wall: dir.wall, opposite: dir.opp });
          }
        }
        return neighbors;
      }
    }

    function setupGrid() {
      grid = [];
      for (let y = 0; y < ROWS; y++) {
        const row = [];
        for (let x = 0; x < COLS; x++) {
          row.push(new Cell(x, y));
        }
        grid.push(row);
      }
    }

    function generateMaze() {
      setupGrid();

      const stack = [];
      let current = grid[0][0];
      current.visited = true;

      while (true) {
        const neighbors = current.getNeighbors(grid);

        if (neighbors.length > 0) {
          const r = Math.floor(Math.random() * neighbors.length);
          const { cell: next, wall, opposite } = neighbors[r];

          current.walls[wall] = false;
          next.walls[opposite] = false;

          stack.push(current);
          current = next;
          current.visited = true;
        } else if (stack.length > 0) {
          current = stack.pop();
        } else {
          break;
        }
      }

      // –û—Ç–∫—Ä—ã–≤–∞–µ–º –≤—ã—Ö–æ–¥
      grid[exit.y][exit.x].walls.bottom = false;
    }

    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          grid[y][x].draw();
        }
      }

      // –ò–≥—Ä–æ–∫
      const px = player.x * CELL_SIZE + CELL_SIZE / 2;
      const py = player.y * CELL_SIZE + CELL_SIZE / 2;
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(px, py, CELL_SIZE / 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = `bold ${CELL_SIZE - 6}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üòé', px, py);

      // –í—ã—Ö–æ–¥
      const ex = exit.x * CELL_SIZE + CELL_SIZE / 2;
      const ey = exit.y * CELL_SIZE + CELL_SIZE / 2;
      ctx.fillText('üö™', ex, ey);
    }

    function canMoveTo(newX, newY) {
      if (newX < 0 || newY < 0 || newX >= COLS || newY >= ROWS) return false;

      if (newX < player.x) return !grid[player.y][player.x].walls.left;
      if (newX > player.x) return !grid[player.y][player.x].walls.right;
      if (newY < player.y) return !grid[player.y][player.x].walls.top;
      if (newY > player.y) return !grid[player.y][player.x].walls.bottom;

      return false;
    }

    function movePlayer(dx, dy) {
      if (gameWon) return;

      const newX = player.x + dx;
      const newY = player.y + dy;

      if (canMoveTo(newX, newY)) {
        player.x = newX;
        player.y = newY;
        drawMaze();

        if (player.x === exit.x && player.y === exit.y) {
          gameWon = true;
          winImage.style.display = 'block';
          stopTimer();
        }
      }
    }

    let timeLeft = 1 * 60; // 5 –º–∏–Ω—É—Ç
    let timerInterval;

    function updateTimer() {
      const minutes = Math.floor(timeLeft / 60);
      const seconds = timeLeft % 60;
      timeDisplay.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }

    function startTimer() {
      updateTimer();
      timerInterval = setInterval(() => {
        timeLeft--;

        if (timeLeft <= 0) {
          stopTimer();
          setTimeout(() => {
            location.reload();
          }, 600);
        } else {
          updateTimer();
        }
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
    }

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    document.addEventListener('keydown', (e) => {
      if (gameWon) return;
      switch (e.key) {
        case 'ArrowUp': e.preventDefault(); movePlayer(0, -1); break;
        case 'ArrowDown': e.preventDefault(); movePlayer(0, 1); break;
        case 'ArrowLeft': e.preventDefault(); movePlayer(-1, 0); break;
        case 'ArrowRight': e.preventDefault(); movePlayer(1, 0); break;
      }
    });

    // –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –∏ –∫–ª–∏–∫-—Å–æ–±—ã—Ç–∏—è
    document.getElementById('up').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(0, -1); });
    document.getElementById('down').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(0, 1); });
    document.getElementById('left').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(-1, 0); });
    document.getElementById('right').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(1, 0); });

    document.getElementById('up').addEventListener('click', () => movePlayer(0, -1));
    document.getElementById('down').addEventListener('click', () => movePlayer(0, 1));
    document.getElementById('left').addEventListener('click', () => movePlayer(-1, 0));
    document.getElementById('right').addEventListener('click', () => movePlayer(1, 0));

    // –ó–∞–ø—É—Å–∫
    window.onload = () => {
      generateMaze();
      drawMaze();
      startTimer();
    };
  </script>
</body>
</html>