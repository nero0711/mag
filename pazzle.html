<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PNG → плитки по зелёным разделителям (0,255,0) + DnD swap</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #121a33;
      --muted: #94a3b8;
      --accent: #22c55e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100svh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% -10%, #1b2650, transparent 70%),
                  radial-gradient(1000px 600px at 120% 10%, #11204d, transparent 70%),
                  var(--bg);
      color: #e5e7eb;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 20px;
    }
    header {
      padding: 18px 20px 0;
    }
    h1 { font-size: 20px; font-weight: 700; margin: 0 0 8px; }
    p { margin: 0; color: var(--muted); }

    .toolbar {
      display: flex; gap: 12px; align-items: center;
      padding: 0 20px;
    }

    .dropzone {
      margin: 12px 20px;
      border: 2px dashed #334155;
      background: color-mix(in oklab, var(--card) 85%, white 15%);
      border-radius: 16px;
      min-height: 140px;
      display: grid; place-items: center; text-align: center;
      cursor: pointer;
      position: relative;
      transition: border-color .2s ease, background .2s ease, transform .1s ease;
    }

    #gridWrap {
      margin: 0 20px 20px;
      padding: 16px;
      border-radius: 16px;
      overflow: auto;
    }

    /* Динамическая сетка подстраивается под размеры плиток */
    #grid {
      display: grid;
      gap: 0; /* у нас нет зазоров — они были в изображении зелёными линиями */
      justify-content: start; /* без растягивания */
      align-content: start;
      user-select: none;
    }

    .tile {
      outline: 1px solid rgba(255,255,255,.08);
      position: relative;
    }
    .tile:focus { outline: 2px solid var(--accent); }
    .tile[draggable="true"] { cursor: grab; }
    .tile.dragging { opacity: .6; cursor: grabbing; }
    .tile.drop-target { box-shadow: inset 0 0 0 2px var(--accent); }

    .hint {
      margin: 0 20px 12px;
      color: var(--muted);
      font-size: 13px;
    }

    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #0f172a; border: 1px solid #1f2a4a; color: #a5b4fc; font-variant-numeric: tabular-nums; }
  </style>
</head>
<body>

  <label id="dropzone" class="dropzone" tabindex="0">
    <div id="container">
      <h2>Нажмите для загрузки PNG</h2>
    </div>
    <input id="fileInput" type="file" accept="image/png" hidden />

    <div class="hint" id="hint"></div>

    <div id="gridWrap">
      <div id="grid" aria-label="Пазл"></div>
    </div>
  </label>

<script>
(() => {
  const GREEN = { r:0, g:255, b:0 };
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const grid = document.getElementById('grid');
  const gridWrap = document.getElementById('gridWrap');
  const meta = document.getElementById('meta');
  const hint = document.getElementById('hint');
  const container = document.getElementById('container');

  fileInput.addEventListener('change', () => {
    const f = fileInput.files?.[0];
    if (f) handleFile(f);
  });

  function errorMsg(msg) {
    hint.textContent = msg;
    hint.style.color = '#fca5a5';
  }
  function infoMsg(msg) {
    hint.textContent = msg;
    hint.style.color = '';
  }

  async function handleFile(file) {
    if (file.type !== 'image/png') { errorMsg('Пожалуйста, выберите PNG-файл.'); return; }
    const url = URL.createObjectURL(file);
    try {
      const img = await loadImage(url);
      URL.revokeObjectURL(url);
      processImage(img);
      container.remove();
      fileInput.remove();
    } catch (err) {
      console.error(err);
      errorMsg('Не удалось загрузить изображение.');
    }
  }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  function processImage(img) {
    // Рисуем в оффскрин канвас и анализируем пиксели
    const c = document.createElement('canvas');
    c.width = img.naturalWidth; c.height = img.naturalHeight;
    const ctx = c.getContext('2d', { willReadFrequently: true });
    ctx.drawImage(img, 0, 0);
    const { width: W, height: H } = c;
    const data = ctx.getImageData(0, 0, W, H).data;

    const isRowGreen = (y) => {
      const yOff = y * W * 4;
      for (let x = 0; x < W; x++) {
        const i = yOff + x*4;
        if (!(data[i] === GREEN.r && data[i+1] === GREEN.g && data[i+2] === GREEN.b && data[i+3] !== 0)) return false;
      }
      return true;
    };
    const isColGreen = (x) => {
      const xOff = x*4;
      for (let y = 0; y < H; y++) {
        const i = y*W*4 + xOff;
        if (!(data[i] === GREEN.r && data[i+1] === GREEN.g && data[i+2] === GREEN.b && data[i+3] !== 0)) return false;
      }
      return true;
    };

    // Находим полосы зелёных разделителей (могут быть толще 1 пикселя)
    const rowSep = [];
    for (let y = 0; y < H; y++) if (isRowGreen(y)) rowSep.push(y);
    const colSep = [];
    for (let x = 0; x < W; x++) if (isColGreen(x)) colSep.push(x);

    const bands = (idxs) => {
      const res = [];
      let start = null;
      for (let i = 0; i < idxs.length; i++) {
        if (start === null) start = idxs[i];
        const cur = idxs[i];
        const next = idxs[i+1];
        if (next !== cur + 1) { res.push([start, cur]); start = null; }
      }
      if (start !== null) res.push([start, idxs[idxs.length-1]]);
      return res;
    };

    const rowBands = bands(rowSep);
    const colBands = bands(colSep);

    // Получаем диапазоны рядов/колонок плиток между зелёными полосами
    const rows = [];
    let prev = 0;
    if (rowBands.length === 0) {
      rows.push([0, H-1]);
    } else {
      for (let i = 0; i <= rowBands.length; i++) {
        const bandStart = rowBands[i]?.[0] ?? H; // для последнего сегмента
        const top = prev;
        const bottom = bandStart - 1;
        if (bottom >= top) rows.push([top, bottom]);
        prev = (rowBands[i]?.[1] ?? (H-1)) + 1;
      }
    }

    const cols = [];
    prev = 0;
    if (colBands.length === 0) {
      cols.push([0, W-1]);
    } else {
      for (let i = 0; i <= colBands.length; i++) {
        const bandStart = colBands[i]?.[0] ?? W;
        const left = prev;
        const right = bandStart - 1;
        if (right >= left) cols.push([left, right]);
        prev = (colBands[i]?.[1] ?? (W-1)) + 1;
      }
    }

    // Размеры плиток по пикселям
    const rowHeights = rows.map(([t,b]) => b - t + 1);
    const colWidths  = cols.map(([l,r]) => r - l + 1);

    // Применяем шаблон CSS grid под реальные размеры
    grid.style.gridTemplateColumns = colWidths.map(px => `${px}px`).join(' ');
    grid.style.gridTemplateRows    = rowHeights.map(px => `${px}px`).join(' ');

    // Чистим грид
    grid.innerHTML = '';

    // Рисуем плитки
    const tiles = []; // будем хранить DOM-элементы плиток
    for (let ry = 0; ry < rows.length; ry++) {
      const [top] = rows[ry];
      const h = rowHeights[ry];
      for (let cx = 0; cx < cols.length; cx++) {
        const [left] = cols[cx];
        const w = colWidths[cx];
        // Вырезаем ImageData
        const tileData = ctx.getImageData(left, top, w, h);
        const tileCanvas = document.createElement('canvas');
        tileCanvas.width = w; tileCanvas.height = h;
        const tctx = tileCanvas.getContext('2d');
        tctx.putImageData(tileData, 0, 0);

        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('draggable', 'true');
        tile.style.gridColumnStart = (cx + 1);
        tile.style.gridRowStart = (ry + 1);
        tile.appendChild(tileCanvas);
        tile.dataset.col = String(cx);
        tile.dataset.row = String(ry);

        makeDraggable(tile);

        grid.appendChild(tile);
        tiles.push(tile);
      }
    }

    // Скролл к сетке, если она большая
    queueMicrotask(() => gridWrap.scrollIntoView({ behavior: 'smooth', block: 'start' }));
  }

  // --- Drag & Drop со swap мест ---
  let dragSrc = null; // элемент .tile

  function makeDraggable(tile) {
    tile.addEventListener('dragstart', (e) => {
      dragSrc = tile;
      tile.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      // Firefox требует данные
      e.dataTransfer.setData('text/plain', `${tile.dataset.row},${tile.dataset.col}`);
    });
    tile.addEventListener('dragend', () => {
      tile.classList.remove('dragging');
      dragSrc = null;
      [...grid.children].forEach(el => el.classList.remove('drop-target'));
    });

    tile.addEventListener('dragover', (e) => {
      e.preventDefault(); // нужно, чтобы сработал drop
      if (tile !== dragSrc) tile.classList.add('drop-target');
      e.dataTransfer.dropEffect = 'move';
    });
    tile.addEventListener('dragleave', () => tile.classList.remove('drop-target'));

    tile.addEventListener('drop', (e) => {
      e.preventDefault();
      tile.classList.remove('drop-target');
      if (!dragSrc || dragSrc === tile) return;
      swapTiles(dragSrc, tile);
    });
  }

  function swapTiles(a, b) {
    // Меняем их позиции в сетке, переставляя grid-row-start / grid-column-start
    const aRow = a.style.gridRowStart; const aCol = a.style.gridColumnStart;
    const bRow = b.style.gridRowStart; const bCol = b.style.gridColumnStart;

    a.style.gridRowStart = bRow; a.style.gridColumnStart = bCol;
    b.style.gridRowStart = aRow; b.style.gridColumnStart = aCol;

    // Обновим атрибуты для удобства
    a.dataset.row = String(Number(bRow)-1); a.dataset.col = String(Number(bCol)-1);
    b.dataset.row = String(Number(aRow)-1); b.dataset.col = String(Number(aCol)-1);
  }
})();
</script>
</body>
</html>
