<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title></title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #121a33;
      --muted: #94a3b8;
      --accent: #22c55e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100svh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% -10%, #1b2650, transparent 70%),
                  radial-gradient(1000px 600px at 120% 10%, #11204d, transparent 70%),
                  var(--bg);
      color: #e5e7eb;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 20px;
    }
    header {
      padding: 18px 20px 0;
    }
    h1 { font-size: 20px; font-weight: 700; margin: 0 0 8px; }
    p { margin: 0; color: var(--muted); }

    .toolbar {
      display: flex; gap: 12px; align-items: center;
      padding: 0 20px;
    }

    .dropzone {
      margin: 12px 20px;
      border: 2px dashed #334155;
      background: color-mix(in oklab, var(--card) 85%, white 15%);
      border-radius: 16px;
      min-height: 140px;
      display: grid; place-items: center; text-align: center;
      cursor: pointer;
      position: relative;
      transition: border-color .2s ease, background .2s ease, transform .1s ease;
    }

    #gridWrap {
      margin: 0 20px 20px;
      padding: 16px 0;   /* —É–±—Ä–∞–ª–∏ –ø–∞–¥–¥–∏–Ω–≥ –ø–æ –±–æ–∫–∞–º */
      border-radius: 16px;
      overflow: auto;
      width: 100%;
    }


    /* –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å–µ—Ç–∫–∞ –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –ø–æ–¥ —Ä–∞–∑–º–µ—Ä—ã –ø–ª–∏—Ç–æ–∫ */
    #grid {
      display: grid;
      gap: 0;
      justify-content: start;
      align-content: start;
      user-select: none;
    }

    .tile {
      outline: 1px solid rgba(255,255,255,.08);
      position: relative;
    }
    .tile:focus { outline: 2px solid var(--accent); }
    .tile[draggable="true"] { cursor: grab; }
    .tile.dragging { opacity: .6; cursor: grabbing; }
    .tile.drop-target { box-shadow: inset 0 0 0 2px var(--accent); }

    .hint {
      margin: 0 20px 12px;
      color: var(--muted);
      font-size: 13px;
    }
    .title_dev {
        font-size: 20px;
        font-weight: 700;
        margin: 20px 0px 0px 0px;
        justify-content: center;
        display: flex;
    }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #0f172a; border: 1px solid #1f2a4a; color: #a5b4fc; font-variant-numeric: tabular-nums; }
  </style>
</head>
<body>
    <div class="title_dev" > üì≤&nbsp;&nbsp;–°–æ–±–∏—Ä–∞—Ç–æ—Ä</div>
    <label id="dropzone" class="dropzone" tabindex="0">
        <div id="container">
          <h2>–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ PNG</h2>
        </div>
        <input id="fileInput" type="file" accept="image/png" hidden />
        <div class="hint" id="hint"></div>
        <div id="gridWrap">
          <div id="grid" aria-label="–ü–∞–∑–ª"></div>
        </div>
    </label>

<script>
(() => {
  const GREEN = { r:0, g:255, b:0 };
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const grid = document.getElementById('grid');
  const gridWrap = document.getElementById('gridWrap');
  const hint = document.getElementById('hint');
  const container = document.getElementById('container');

  fileInput.addEventListener('change', () => {
    const f = fileInput.files?.[0];
    if (f) handleFile(f);
  });

  function errorMsg(msg) {
    hint.textContent = msg;
    hint.style.color = '#fca5a5';
  }
  function infoMsg(msg) {
    hint.textContent = msg;
    hint.style.color = '';
  }

  async function handleFile(file) {
    if (file.type !== 'image/png') { errorMsg('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ PNG-—Ñ–∞–π–ª.'); return; }
    const url = URL.createObjectURL(file);
    try {
      const img = await loadImage(url);
      URL.revokeObjectURL(url);
      processImage(img);
      container.remove();
      fileInput.remove();
    } catch (err) {
      console.error(err);
      errorMsg('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
    }
  }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  function processImage(img) {
    const c = document.createElement('canvas');
    c.width = img.naturalWidth; c.height = img.naturalHeight;
    const ctx = c.getContext('2d', { willReadFrequently: true });
    ctx.drawImage(img, 0, 0);
    const { width: W, height: H } = c;
    const data = ctx.getImageData(0, 0, W, H).data;

    const isRowGreen = (y) => {
      const yOff = y * W * 4;
      for (let x = 0; x < W; x++) {
        const i = yOff + x*4;
        if (!(data[i] === GREEN.r && data[i+1] === GREEN.g && data[i+2] === GREEN.b && data[i+3] !== 0)) return false;
      }
      return true;
    };
    const isColGreen = (x) => {
      const xOff = x*4;
      for (let y = 0; y < H; y++) {
        const i = y*W*4 + xOff;
        if (!(data[i] === GREEN.r && data[i+1] === GREEN.g && data[i+2] === GREEN.b && data[i+3] !== 0)) return false;
      }
      return true;
    };

    const bands = (idxs) => {
      const res = [];
      let start = null;
      for (let i = 0; i < idxs.length; i++) {
        if (start === null) start = idxs[i];
        const cur = idxs[i];
        const next = idxs[i+1];
        if (next !== cur + 1) { res.push([start, cur]); start = null; }
      }
      if (start !== null) res.push([start, idxs[idxs.length-1]]);
      return res;
    };

    const rowBands = bands([...Array(H).keys()].filter(isRowGreen));
    const colBands = bands([...Array(W).keys()].filter(isColGreen));

    const rows = [];
    let prev = 0;
    if (rowBands.length === 0) {
      rows.push([0, H-1]);
    } else {
      for (let i = 0; i <= rowBands.length; i++) {
        const bandStart = rowBands[i]?.[0] ?? H;
        const top = prev;
        const bottom = bandStart - 1;
        if (bottom >= top) rows.push([top, bottom]);
        prev = (rowBands[i]?.[1] ?? (H-1)) + 1;
      }
    }

    const cols = [];
    prev = 0;
    if (colBands.length === 0) {
      cols.push([0, W-1]);
    } else {
      for (let i = 0; i <= colBands.length; i++) {
        const bandStart = colBands[i]?.[0] ?? W;
        const left = prev;
        const right = bandStart - 1;
        if (right >= left) cols.push([left, right]);
        prev = (colBands[i]?.[1] ?? (W-1)) + 1;
      }
    }

    // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–±
    const styles = getComputedStyle(gridWrap);
    const paddingLeft = parseFloat(styles.paddingLeft);
    const paddingRight = parseFloat(styles.paddingRight);
    const maxWidth = gridWrap.clientWidth - paddingLeft - paddingRight;
    const scale = Math.min(1, maxWidth / W);

    const rowHeights = rows.map(([t,b]) => (b - t + 1) * scale);
    const colWidths  = cols.map(([l,r]) => (r - l + 1) * scale);

    grid.style.gridTemplateColumns = colWidths.map(px => `${px}px`).join(' ');
    grid.style.gridTemplateRows    = rowHeights.map(px => `${px}px`).join(' ');

    grid.innerHTML = '';

    for (let ry = 0; ry < rows.length; ry++) {
      const [top] = rows[ry];
      const h = rows[ry][1] - top + 1;
      for (let cx = 0; cx < cols.length; cx++) {
        const [left] = cols[cx];
        const w = cols[cx][1] - left + 1;

        const tileData = ctx.getImageData(left, top, w, h);
        const tileCanvas = document.createElement('canvas');
        tileCanvas.width = w; tileCanvas.height = h;
        const tctx = tileCanvas.getContext('2d');
        tctx.putImageData(tileData, 0, 0);

        // –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ CSS
        tileCanvas.style.width = (w * scale) + "px";
        tileCanvas.style.height = (h * scale) + "px";

        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('draggable', 'true');
        tile.style.gridColumnStart = (cx + 1);
        tile.style.gridRowStart = (ry + 1);
        tile.appendChild(tileCanvas);
        tile.dataset.col = String(cx);
        tile.dataset.row = String(ry);

        makeDraggable(tile);

        grid.appendChild(tile);
      }
    }

    queueMicrotask(() => gridWrap.scrollIntoView({ behavior: 'smooth', block: 'start' }));
  }

  // Drag & Drop
  let dragSrc = null;
  function makeDraggable(tile) {
    tile.addEventListener('dragstart', (e) => {
      dragSrc = tile;
      tile.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', `${tile.dataset.row},${tile.dataset.col}`);
    });
    tile.addEventListener('dragend', () => {
      tile.classList.remove('dragging');
      dragSrc = null;
      [...grid.children].forEach(el => el.classList.remove('drop-target'));
    });

    tile.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (tile !== dragSrc) tile.classList.add('drop-target');
      e.dataTransfer.dropEffect = 'move';
    });
    tile.addEventListener('dragleave', () => tile.classList.remove('drop-target'));

    tile.addEventListener('drop', (e) => {
      e.preventDefault();
      tile.classList.remove('drop-target');
      if (!dragSrc || dragSrc === tile) return;
      swapTiles(dragSrc, tile);
    });
  }

  function swapTiles(a, b) {
    const aRow = a.style.gridRowStart; const aCol = a.style.gridColumnStart;
    const bRow = b.style.gridRowStart; const bCol = b.style.gridColumnStart;

    a.style.gridRowStart = bRow; a.style.gridColumnStart = bCol;
    b.style.gridRowStart = aRow; b.style.gridColumnStart = aCol;

    a.dataset.row = String(Number(bRow)-1); a.dataset.col = String(Number(bCol)-1);
    b.dataset.row = String(Number(aRow)-1); b.dataset.col = String(Number(aCol)-1);
  }
})();
</script>
</body>
</html>
